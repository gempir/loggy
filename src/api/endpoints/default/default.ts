/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  ChannelIdType,
  ChannelLogsStats,
  GetChannelIdTypeChannelParams,
  GetChannelIdTypeChannelRandomParams,
  GetChannelIdTypeChannelStatsParams,
  GetChannelIdTypeChannelUserIdTypeUserParams,
  GetChannelIdTypeChannelUserIdTypeUserRandomParams,
  GetChannelIdTypeChannelUserIdTypeUserSearchParams,
  GetChannelIdTypeChannelUserIdTypeUserStatsParams,
  GetChannelIdTypeChannelUserIdTypeUserYearMonthParams,
  GetChannelIdTypeChannelYearMonthDayParams,
  JsonLogsResponse,
  PreviousName,
  UserIdType,
  UserLogsStats
} from '../../model';

import { customFetch } from '../../fetcher';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * List logged channels
 */
export type getChannelsResponseDefault = {
  data: unknown
  status: number
}
    
;
export type getChannelsResponseError = (getChannelsResponseDefault) & {
  headers: Headers;
};

export type getChannelsResponse = (getChannelsResponseError)

export const getGetChannelsUrl = () => {


  

  return `https://logs.ivr.fi/channels`
}

export const getChannels = async ( options?: RequestInit): Promise<getChannelsResponse> => {
  
  return customFetch<getChannelsResponse>(getGetChannelsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetChannelsQueryKey = () => {
    return [
    `https://logs.ivr.fi/channels`
    ] as const;
    }

    
export const getGetChannelsQueryOptions = <TData = Awaited<ReturnType<typeof getChannels>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannels>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetChannelsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getChannels>>> = ({ signal }) => getChannels({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getChannels>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetChannelsQueryResult = NonNullable<Awaited<ReturnType<typeof getChannels>>>
export type GetChannelsQueryError = unknown


export function useGetChannels<TData = Awaited<ReturnType<typeof getChannels>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannels>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannels>>,
          TError,
          Awaited<ReturnType<typeof getChannels>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetChannels<TData = Awaited<ReturnType<typeof getChannels>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannels>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannels>>,
          TError,
          Awaited<ReturnType<typeof getChannels>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetChannels<TData = Awaited<ReturnType<typeof getChannels>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannels>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetChannels<TData = Awaited<ReturnType<typeof getChannels>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannels>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetChannelsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * List available logs
 */
export type getListResponseDefault = {
  data: unknown
  status: number
}
    
;
export type getListResponseError = (getListResponseDefault) & {
  headers: Headers;
};

export type getListResponse = (getListResponseError)

export const getGetListUrl = () => {


  

  return `https://logs.ivr.fi/list`
}

export const getList = async ( options?: RequestInit): Promise<getListResponse> => {
  
  return customFetch<getListResponse>(getGetListUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetListQueryKey = () => {
    return [
    `https://logs.ivr.fi/list`
    ] as const;
    }

    
export const getGetListQueryOptions = <TData = Awaited<ReturnType<typeof getList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getList>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getList>>> = ({ signal }) => getList({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetListQueryResult = NonNullable<Awaited<ReturnType<typeof getList>>>
export type GetListQueryError = unknown


export function useGetList<TData = Awaited<ReturnType<typeof getList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getList>>,
          TError,
          Awaited<ReturnType<typeof getList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetList<TData = Awaited<ReturnType<typeof getList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getList>>,
          TError,
          Awaited<ReturnType<typeof getList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetList<TData = Awaited<ReturnType<typeof getList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getList>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetList<TData = Awaited<ReturnType<typeof getList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getList>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetListQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get user name history by provided user id
 */
export type getNamehistoryUserIdResponse200 = {
  data: PreviousName[]
  status: 200
}
    
export type getNamehistoryUserIdResponseSuccess = (getNamehistoryUserIdResponse200) & {
  headers: Headers;
};
;

export type getNamehistoryUserIdResponse = (getNamehistoryUserIdResponseSuccess)

export const getGetNamehistoryUserIdUrl = (userId: string,) => {


  

  return `https://logs.ivr.fi/namehistory/${userId}`
}

export const getNamehistoryUserId = async (userId: string, options?: RequestInit): Promise<getNamehistoryUserIdResponse> => {
  
  return customFetch<getNamehistoryUserIdResponse>(getGetNamehistoryUserIdUrl(userId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetNamehistoryUserIdQueryKey = (userId?: string,) => {
    return [
    `https://logs.ivr.fi/namehistory/${userId}`
    ] as const;
    }

    
export const getGetNamehistoryUserIdQueryOptions = <TData = Awaited<ReturnType<typeof getNamehistoryUserId>>, TError = unknown>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNamehistoryUserId>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNamehistoryUserIdQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNamehistoryUserId>>> = ({ signal }) => getNamehistoryUserId(userId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNamehistoryUserId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetNamehistoryUserIdQueryResult = NonNullable<Awaited<ReturnType<typeof getNamehistoryUserId>>>
export type GetNamehistoryUserIdQueryError = unknown


export function useGetNamehistoryUserId<TData = Awaited<ReturnType<typeof getNamehistoryUserId>>, TError = unknown>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNamehistoryUserId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNamehistoryUserId>>,
          TError,
          Awaited<ReturnType<typeof getNamehistoryUserId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNamehistoryUserId<TData = Awaited<ReturnType<typeof getNamehistoryUserId>>, TError = unknown>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNamehistoryUserId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNamehistoryUserId>>,
          TError,
          Awaited<ReturnType<typeof getNamehistoryUserId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNamehistoryUserId<TData = Awaited<ReturnType<typeof getNamehistoryUserId>>, TError = unknown>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNamehistoryUserId>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetNamehistoryUserId<TData = Awaited<ReturnType<typeof getNamehistoryUserId>>, TError = unknown>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNamehistoryUserId>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetNamehistoryUserIdQueryOptions(userId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Search user logs using the provided query
 */
export type getChannelIdTypeChannelUserIdTypeUserSearchResponse200 = {
  data: JsonLogsResponse
  status: 200
}
    
export type getChannelIdTypeChannelUserIdTypeUserSearchResponseSuccess = (getChannelIdTypeChannelUserIdTypeUserSearchResponse200) & {
  headers: Headers;
};
;

export type getChannelIdTypeChannelUserIdTypeUserSearchResponse = (getChannelIdTypeChannelUserIdTypeUserSearchResponseSuccess)

export const getGetChannelIdTypeChannelUserIdTypeUserSearchUrl = (channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    params: GetChannelIdTypeChannelUserIdTypeUserSearchParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://logs.ivr.fi/${channelIdType}/${channel}/${userIdType}/${user}/search?${stringifiedParams}` : `https://logs.ivr.fi/${channelIdType}/${channel}/${userIdType}/${user}/search`
}

export const getChannelIdTypeChannelUserIdTypeUserSearch = async (channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    params: GetChannelIdTypeChannelUserIdTypeUserSearchParams, options?: RequestInit): Promise<getChannelIdTypeChannelUserIdTypeUserSearchResponse> => {
  
  return customFetch<getChannelIdTypeChannelUserIdTypeUserSearchResponse>(getGetChannelIdTypeChannelUserIdTypeUserSearchUrl(channelIdType,channel,userIdType,user,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetChannelIdTypeChannelUserIdTypeUserSearchQueryKey = (channelIdType?: ChannelIdType,
    channel?: string,
    userIdType?: UserIdType,
    user?: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserSearchParams,) => {
    return [
    `https://logs.ivr.fi/${channelIdType}/${channel}/${userIdType}/${user}/search`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetChannelIdTypeChannelUserIdTypeUserSearchQueryOptions = <TData = Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserSearch>>, TError = unknown>(channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    params: GetChannelIdTypeChannelUserIdTypeUserSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserSearch>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetChannelIdTypeChannelUserIdTypeUserSearchQueryKey(channelIdType,channel,userIdType,user,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserSearch>>> = ({ signal }) => getChannelIdTypeChannelUserIdTypeUserSearch(channelIdType,channel,userIdType,user,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(channelIdType && channel && userIdType && user), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserSearch>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetChannelIdTypeChannelUserIdTypeUserSearchQueryResult = NonNullable<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserSearch>>>
export type GetChannelIdTypeChannelUserIdTypeUserSearchQueryError = unknown


export function useGetChannelIdTypeChannelUserIdTypeUserSearch<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserSearch>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    params: GetChannelIdTypeChannelUserIdTypeUserSearchParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserSearch>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserSearch>>,
          TError,
          Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserSearch>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetChannelIdTypeChannelUserIdTypeUserSearch<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserSearch>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    params: GetChannelIdTypeChannelUserIdTypeUserSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserSearch>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserSearch>>,
          TError,
          Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserSearch>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetChannelIdTypeChannelUserIdTypeUserSearch<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserSearch>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    params: GetChannelIdTypeChannelUserIdTypeUserSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserSearch>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetChannelIdTypeChannelUserIdTypeUserSearch<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserSearch>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    params: GetChannelIdTypeChannelUserIdTypeUserSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserSearch>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetChannelIdTypeChannelUserIdTypeUserSearchQueryOptions(channelIdType,channel,userIdType,user,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get user stats
 */
export type getChannelIdTypeChannelUserIdTypeUserStatsResponse200 = {
  data: UserLogsStats
  status: 200
}
    
export type getChannelIdTypeChannelUserIdTypeUserStatsResponseSuccess = (getChannelIdTypeChannelUserIdTypeUserStatsResponse200) & {
  headers: Headers;
};
;

export type getChannelIdTypeChannelUserIdTypeUserStatsResponse = (getChannelIdTypeChannelUserIdTypeUserStatsResponseSuccess)

export const getGetChannelIdTypeChannelUserIdTypeUserStatsUrl = (channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserStatsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://logs.ivr.fi/${channelIdType}/${channel}/${userIdType}/${user}/stats?${stringifiedParams}` : `https://logs.ivr.fi/${channelIdType}/${channel}/${userIdType}/${user}/stats`
}

export const getChannelIdTypeChannelUserIdTypeUserStats = async (channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserStatsParams, options?: RequestInit): Promise<getChannelIdTypeChannelUserIdTypeUserStatsResponse> => {
  
  return customFetch<getChannelIdTypeChannelUserIdTypeUserStatsResponse>(getGetChannelIdTypeChannelUserIdTypeUserStatsUrl(channelIdType,channel,userIdType,user,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetChannelIdTypeChannelUserIdTypeUserStatsQueryKey = (channelIdType?: ChannelIdType,
    channel?: string,
    userIdType?: UserIdType,
    user?: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserStatsParams,) => {
    return [
    `https://logs.ivr.fi/${channelIdType}/${channel}/${userIdType}/${user}/stats`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetChannelIdTypeChannelUserIdTypeUserStatsQueryOptions = <TData = Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserStats>>, TError = unknown>(channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserStatsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserStats>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetChannelIdTypeChannelUserIdTypeUserStatsQueryKey(channelIdType,channel,userIdType,user,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserStats>>> = ({ signal }) => getChannelIdTypeChannelUserIdTypeUserStats(channelIdType,channel,userIdType,user,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(channelIdType && channel && userIdType && user), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetChannelIdTypeChannelUserIdTypeUserStatsQueryResult = NonNullable<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserStats>>>
export type GetChannelIdTypeChannelUserIdTypeUserStatsQueryError = unknown


export function useGetChannelIdTypeChannelUserIdTypeUserStats<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserStats>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    params: undefined |  GetChannelIdTypeChannelUserIdTypeUserStatsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserStats>>,
          TError,
          Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserStats>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetChannelIdTypeChannelUserIdTypeUserStats<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserStats>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserStatsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserStats>>,
          TError,
          Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserStats>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetChannelIdTypeChannelUserIdTypeUserStats<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserStats>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserStatsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserStats>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetChannelIdTypeChannelUserIdTypeUserStats<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserStats>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserStatsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserStats>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetChannelIdTypeChannelUserIdTypeUserStatsQueryOptions(channelIdType,channel,userIdType,user,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get channel stats
 */
export type getChannelIdTypeChannelStatsResponse200 = {
  data: ChannelLogsStats
  status: 200
}
    
export type getChannelIdTypeChannelStatsResponseSuccess = (getChannelIdTypeChannelStatsResponse200) & {
  headers: Headers;
};
;

export type getChannelIdTypeChannelStatsResponse = (getChannelIdTypeChannelStatsResponseSuccess)

export const getGetChannelIdTypeChannelStatsUrl = (channelIdType: ChannelIdType,
    channel: string,
    params?: GetChannelIdTypeChannelStatsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://logs.ivr.fi/${channelIdType}/${channel}/stats?${stringifiedParams}` : `https://logs.ivr.fi/${channelIdType}/${channel}/stats`
}

export const getChannelIdTypeChannelStats = async (channelIdType: ChannelIdType,
    channel: string,
    params?: GetChannelIdTypeChannelStatsParams, options?: RequestInit): Promise<getChannelIdTypeChannelStatsResponse> => {
  
  return customFetch<getChannelIdTypeChannelStatsResponse>(getGetChannelIdTypeChannelStatsUrl(channelIdType,channel,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetChannelIdTypeChannelStatsQueryKey = (channelIdType?: ChannelIdType,
    channel?: string,
    params?: GetChannelIdTypeChannelStatsParams,) => {
    return [
    `https://logs.ivr.fi/${channelIdType}/${channel}/stats`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetChannelIdTypeChannelStatsQueryOptions = <TData = Awaited<ReturnType<typeof getChannelIdTypeChannelStats>>, TError = unknown>(channelIdType: ChannelIdType,
    channel: string,
    params?: GetChannelIdTypeChannelStatsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelStats>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetChannelIdTypeChannelStatsQueryKey(channelIdType,channel,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getChannelIdTypeChannelStats>>> = ({ signal }) => getChannelIdTypeChannelStats(channelIdType,channel,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(channelIdType && channel), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetChannelIdTypeChannelStatsQueryResult = NonNullable<Awaited<ReturnType<typeof getChannelIdTypeChannelStats>>>
export type GetChannelIdTypeChannelStatsQueryError = unknown


export function useGetChannelIdTypeChannelStats<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelStats>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    params: undefined |  GetChannelIdTypeChannelStatsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannelIdTypeChannelStats>>,
          TError,
          Awaited<ReturnType<typeof getChannelIdTypeChannelStats>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetChannelIdTypeChannelStats<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelStats>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    params?: GetChannelIdTypeChannelStatsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannelIdTypeChannelStats>>,
          TError,
          Awaited<ReturnType<typeof getChannelIdTypeChannelStats>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetChannelIdTypeChannelStats<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelStats>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    params?: GetChannelIdTypeChannelStatsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelStats>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetChannelIdTypeChannelStats<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelStats>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    params?: GetChannelIdTypeChannelStatsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelStats>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetChannelIdTypeChannelStatsQueryOptions(channelIdType,channel,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get a random line from the channel's logs
 */
export type getChannelIdTypeChannelRandomResponseDefault = {
  data: unknown
  status: number
}
    
;
export type getChannelIdTypeChannelRandomResponseError = (getChannelIdTypeChannelRandomResponseDefault) & {
  headers: Headers;
};

export type getChannelIdTypeChannelRandomResponse = (getChannelIdTypeChannelRandomResponseError)

export const getGetChannelIdTypeChannelRandomUrl = (channelIdType: ChannelIdType,
    channel: string,
    params?: GetChannelIdTypeChannelRandomParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://logs.ivr.fi/${channelIdType}/${channel}/random?${stringifiedParams}` : `https://logs.ivr.fi/${channelIdType}/${channel}/random`
}

export const getChannelIdTypeChannelRandom = async (channelIdType: ChannelIdType,
    channel: string,
    params?: GetChannelIdTypeChannelRandomParams, options?: RequestInit): Promise<getChannelIdTypeChannelRandomResponse> => {
  
  return customFetch<getChannelIdTypeChannelRandomResponse>(getGetChannelIdTypeChannelRandomUrl(channelIdType,channel,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetChannelIdTypeChannelRandomQueryKey = (channelIdType?: ChannelIdType,
    channel?: string,
    params?: GetChannelIdTypeChannelRandomParams,) => {
    return [
    `https://logs.ivr.fi/${channelIdType}/${channel}/random`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetChannelIdTypeChannelRandomQueryOptions = <TData = Awaited<ReturnType<typeof getChannelIdTypeChannelRandom>>, TError = unknown>(channelIdType: ChannelIdType,
    channel: string,
    params?: GetChannelIdTypeChannelRandomParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelRandom>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetChannelIdTypeChannelRandomQueryKey(channelIdType,channel,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getChannelIdTypeChannelRandom>>> = ({ signal }) => getChannelIdTypeChannelRandom(channelIdType,channel,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(channelIdType && channel), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelRandom>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetChannelIdTypeChannelRandomQueryResult = NonNullable<Awaited<ReturnType<typeof getChannelIdTypeChannelRandom>>>
export type GetChannelIdTypeChannelRandomQueryError = unknown


export function useGetChannelIdTypeChannelRandom<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelRandom>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    params: undefined |  GetChannelIdTypeChannelRandomParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelRandom>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannelIdTypeChannelRandom>>,
          TError,
          Awaited<ReturnType<typeof getChannelIdTypeChannelRandom>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetChannelIdTypeChannelRandom<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelRandom>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    params?: GetChannelIdTypeChannelRandomParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelRandom>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannelIdTypeChannelRandom>>,
          TError,
          Awaited<ReturnType<typeof getChannelIdTypeChannelRandom>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetChannelIdTypeChannelRandom<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelRandom>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    params?: GetChannelIdTypeChannelRandomParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelRandom>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetChannelIdTypeChannelRandom<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelRandom>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    params?: GetChannelIdTypeChannelRandomParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelRandom>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetChannelIdTypeChannelRandomQueryOptions(channelIdType,channel,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get a random line from the user's logs in a channel
 */
export type getChannelIdTypeChannelUserIdTypeUserRandomResponseDefault = {
  data: unknown
  status: number
}
    
;
export type getChannelIdTypeChannelUserIdTypeUserRandomResponseError = (getChannelIdTypeChannelUserIdTypeUserRandomResponseDefault) & {
  headers: Headers;
};

export type getChannelIdTypeChannelUserIdTypeUserRandomResponse = (getChannelIdTypeChannelUserIdTypeUserRandomResponseError)

export const getGetChannelIdTypeChannelUserIdTypeUserRandomUrl = (channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserRandomParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://logs.ivr.fi/${channelIdType}/${channel}/${userIdType}/${user}/random?${stringifiedParams}` : `https://logs.ivr.fi/${channelIdType}/${channel}/${userIdType}/${user}/random`
}

export const getChannelIdTypeChannelUserIdTypeUserRandom = async (channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserRandomParams, options?: RequestInit): Promise<getChannelIdTypeChannelUserIdTypeUserRandomResponse> => {
  
  return customFetch<getChannelIdTypeChannelUserIdTypeUserRandomResponse>(getGetChannelIdTypeChannelUserIdTypeUserRandomUrl(channelIdType,channel,userIdType,user,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetChannelIdTypeChannelUserIdTypeUserRandomQueryKey = (channelIdType?: ChannelIdType,
    channel?: string,
    userIdType?: UserIdType,
    user?: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserRandomParams,) => {
    return [
    `https://logs.ivr.fi/${channelIdType}/${channel}/${userIdType}/${user}/random`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetChannelIdTypeChannelUserIdTypeUserRandomQueryOptions = <TData = Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserRandom>>, TError = unknown>(channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserRandomParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserRandom>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetChannelIdTypeChannelUserIdTypeUserRandomQueryKey(channelIdType,channel,userIdType,user,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserRandom>>> = ({ signal }) => getChannelIdTypeChannelUserIdTypeUserRandom(channelIdType,channel,userIdType,user,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(channelIdType && channel && userIdType && user), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserRandom>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetChannelIdTypeChannelUserIdTypeUserRandomQueryResult = NonNullable<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserRandom>>>
export type GetChannelIdTypeChannelUserIdTypeUserRandomQueryError = unknown


export function useGetChannelIdTypeChannelUserIdTypeUserRandom<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserRandom>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    params: undefined |  GetChannelIdTypeChannelUserIdTypeUserRandomParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserRandom>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserRandom>>,
          TError,
          Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserRandom>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetChannelIdTypeChannelUserIdTypeUserRandom<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserRandom>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserRandomParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserRandom>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserRandom>>,
          TError,
          Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserRandom>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetChannelIdTypeChannelUserIdTypeUserRandom<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserRandom>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserRandomParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserRandom>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetChannelIdTypeChannelUserIdTypeUserRandom<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserRandom>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserRandomParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserRandom>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetChannelIdTypeChannelUserIdTypeUserRandomQueryOptions(channelIdType,channel,userIdType,user,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get channel logs. If the `to` and `from` query params are not given, redirect to latest available day
 */
export type getChannelIdTypeChannelResponseDefault = {
  data: unknown
  status: number
}
    
;
export type getChannelIdTypeChannelResponseError = (getChannelIdTypeChannelResponseDefault) & {
  headers: Headers;
};

export type getChannelIdTypeChannelResponse = (getChannelIdTypeChannelResponseError)

export const getGetChannelIdTypeChannelUrl = (channelIdType: ChannelIdType,
    channel: string,
    params?: GetChannelIdTypeChannelParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://logs.ivr.fi/${channelIdType}/${channel}?${stringifiedParams}` : `https://logs.ivr.fi/${channelIdType}/${channel}`
}

export const getChannelIdTypeChannel = async (channelIdType: ChannelIdType,
    channel: string,
    params?: GetChannelIdTypeChannelParams, options?: RequestInit): Promise<getChannelIdTypeChannelResponse> => {
  
  return customFetch<getChannelIdTypeChannelResponse>(getGetChannelIdTypeChannelUrl(channelIdType,channel,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetChannelIdTypeChannelQueryKey = (channelIdType?: ChannelIdType,
    channel?: string,
    params?: GetChannelIdTypeChannelParams,) => {
    return [
    `https://logs.ivr.fi/${channelIdType}/${channel}`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetChannelIdTypeChannelQueryOptions = <TData = Awaited<ReturnType<typeof getChannelIdTypeChannel>>, TError = unknown>(channelIdType: ChannelIdType,
    channel: string,
    params?: GetChannelIdTypeChannelParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannel>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetChannelIdTypeChannelQueryKey(channelIdType,channel,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getChannelIdTypeChannel>>> = ({ signal }) => getChannelIdTypeChannel(channelIdType,channel,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(channelIdType && channel), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannel>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetChannelIdTypeChannelQueryResult = NonNullable<Awaited<ReturnType<typeof getChannelIdTypeChannel>>>
export type GetChannelIdTypeChannelQueryError = unknown


export function useGetChannelIdTypeChannel<TData = Awaited<ReturnType<typeof getChannelIdTypeChannel>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    params: undefined |  GetChannelIdTypeChannelParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannel>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannelIdTypeChannel>>,
          TError,
          Awaited<ReturnType<typeof getChannelIdTypeChannel>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetChannelIdTypeChannel<TData = Awaited<ReturnType<typeof getChannelIdTypeChannel>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    params?: GetChannelIdTypeChannelParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannel>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannelIdTypeChannel>>,
          TError,
          Awaited<ReturnType<typeof getChannelIdTypeChannel>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetChannelIdTypeChannel<TData = Awaited<ReturnType<typeof getChannelIdTypeChannel>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    params?: GetChannelIdTypeChannelParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannel>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetChannelIdTypeChannel<TData = Awaited<ReturnType<typeof getChannelIdTypeChannel>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    params?: GetChannelIdTypeChannelParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannel>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetChannelIdTypeChannelQueryOptions(channelIdType,channel,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get user logs by name. If the `to` and `from` query params are not given, redirect to latest available month
 */
export type getChannelIdTypeChannelUserIdTypeUserResponseDefault = {
  data: unknown
  status: number
}
    
;
export type getChannelIdTypeChannelUserIdTypeUserResponseError = (getChannelIdTypeChannelUserIdTypeUserResponseDefault) & {
  headers: Headers;
};

export type getChannelIdTypeChannelUserIdTypeUserResponse = (getChannelIdTypeChannelUserIdTypeUserResponseError)

export const getGetChannelIdTypeChannelUserIdTypeUserUrl = (channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://logs.ivr.fi/${channelIdType}/${channel}/${userIdType}/${user}?${stringifiedParams}` : `https://logs.ivr.fi/${channelIdType}/${channel}/${userIdType}/${user}`
}

export const getChannelIdTypeChannelUserIdTypeUser = async (channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserParams, options?: RequestInit): Promise<getChannelIdTypeChannelUserIdTypeUserResponse> => {
  
  return customFetch<getChannelIdTypeChannelUserIdTypeUserResponse>(getGetChannelIdTypeChannelUserIdTypeUserUrl(channelIdType,channel,userIdType,user,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetChannelIdTypeChannelUserIdTypeUserQueryKey = (channelIdType?: ChannelIdType,
    channel?: string,
    userIdType?: UserIdType,
    user?: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserParams,) => {
    return [
    `https://logs.ivr.fi/${channelIdType}/${channel}/${userIdType}/${user}`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetChannelIdTypeChannelUserIdTypeUserQueryOptions = <TData = Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUser>>, TError = unknown>(channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUser>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetChannelIdTypeChannelUserIdTypeUserQueryKey(channelIdType,channel,userIdType,user,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUser>>> = ({ signal }) => getChannelIdTypeChannelUserIdTypeUser(channelIdType,channel,userIdType,user,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(channelIdType && channel && userIdType && user), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetChannelIdTypeChannelUserIdTypeUserQueryResult = NonNullable<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUser>>>
export type GetChannelIdTypeChannelUserIdTypeUserQueryError = unknown


export function useGetChannelIdTypeChannelUserIdTypeUser<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUser>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    params: undefined |  GetChannelIdTypeChannelUserIdTypeUserParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUser>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUser>>,
          TError,
          Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUser>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetChannelIdTypeChannelUserIdTypeUser<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUser>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUser>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUser>>,
          TError,
          Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUser>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetChannelIdTypeChannelUserIdTypeUser<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUser>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUser>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetChannelIdTypeChannelUserIdTypeUser<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUser>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUser>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetChannelIdTypeChannelUserIdTypeUserQueryOptions(channelIdType,channel,userIdType,user,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get channel logs from the given day
 */
export type getChannelIdTypeChannelYearMonthDayResponseDefault = {
  data: unknown
  status: number
}
    
;
export type getChannelIdTypeChannelYearMonthDayResponseError = (getChannelIdTypeChannelYearMonthDayResponseDefault) & {
  headers: Headers;
};

export type getChannelIdTypeChannelYearMonthDayResponse = (getChannelIdTypeChannelYearMonthDayResponseError)

export const getGetChannelIdTypeChannelYearMonthDayUrl = (channelIdType: ChannelIdType,
    channel: string,
    year: string,
    month: string,
    day: string,
    params?: GetChannelIdTypeChannelYearMonthDayParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://logs.ivr.fi/${channelIdType}/${channel}/${year}/${month}/${day}?${stringifiedParams}` : `https://logs.ivr.fi/${channelIdType}/${channel}/${year}/${month}/${day}`
}

export const getChannelIdTypeChannelYearMonthDay = async (channelIdType: ChannelIdType,
    channel: string,
    year: string,
    month: string,
    day: string,
    params?: GetChannelIdTypeChannelYearMonthDayParams, options?: RequestInit): Promise<getChannelIdTypeChannelYearMonthDayResponse> => {
  
  return customFetch<getChannelIdTypeChannelYearMonthDayResponse>(getGetChannelIdTypeChannelYearMonthDayUrl(channelIdType,channel,year,month,day,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetChannelIdTypeChannelYearMonthDayQueryKey = (channelIdType?: ChannelIdType,
    channel?: string,
    year?: string,
    month?: string,
    day?: string,
    params?: GetChannelIdTypeChannelYearMonthDayParams,) => {
    return [
    `https://logs.ivr.fi/${channelIdType}/${channel}/${year}/${month}/${day}`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetChannelIdTypeChannelYearMonthDayQueryOptions = <TData = Awaited<ReturnType<typeof getChannelIdTypeChannelYearMonthDay>>, TError = unknown>(channelIdType: ChannelIdType,
    channel: string,
    year: string,
    month: string,
    day: string,
    params?: GetChannelIdTypeChannelYearMonthDayParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelYearMonthDay>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetChannelIdTypeChannelYearMonthDayQueryKey(channelIdType,channel,year,month,day,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getChannelIdTypeChannelYearMonthDay>>> = ({ signal }) => getChannelIdTypeChannelYearMonthDay(channelIdType,channel,year,month,day,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(channelIdType && channel && year && month && day), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelYearMonthDay>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetChannelIdTypeChannelYearMonthDayQueryResult = NonNullable<Awaited<ReturnType<typeof getChannelIdTypeChannelYearMonthDay>>>
export type GetChannelIdTypeChannelYearMonthDayQueryError = unknown


export function useGetChannelIdTypeChannelYearMonthDay<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelYearMonthDay>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    year: string,
    month: string,
    day: string,
    params: undefined |  GetChannelIdTypeChannelYearMonthDayParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelYearMonthDay>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannelIdTypeChannelYearMonthDay>>,
          TError,
          Awaited<ReturnType<typeof getChannelIdTypeChannelYearMonthDay>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetChannelIdTypeChannelYearMonthDay<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelYearMonthDay>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    year: string,
    month: string,
    day: string,
    params?: GetChannelIdTypeChannelYearMonthDayParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelYearMonthDay>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannelIdTypeChannelYearMonthDay>>,
          TError,
          Awaited<ReturnType<typeof getChannelIdTypeChannelYearMonthDay>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetChannelIdTypeChannelYearMonthDay<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelYearMonthDay>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    year: string,
    month: string,
    day: string,
    params?: GetChannelIdTypeChannelYearMonthDayParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelYearMonthDay>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetChannelIdTypeChannelYearMonthDay<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelYearMonthDay>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    year: string,
    month: string,
    day: string,
    params?: GetChannelIdTypeChannelYearMonthDayParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelYearMonthDay>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetChannelIdTypeChannelYearMonthDayQueryOptions(channelIdType,channel,year,month,day,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get user logs in a channel from the given month
 */
export type getChannelIdTypeChannelUserIdTypeUserYearMonthResponseDefault = {
  data: unknown
  status: number
}
    
;
export type getChannelIdTypeChannelUserIdTypeUserYearMonthResponseError = (getChannelIdTypeChannelUserIdTypeUserYearMonthResponseDefault) & {
  headers: Headers;
};

export type getChannelIdTypeChannelUserIdTypeUserYearMonthResponse = (getChannelIdTypeChannelUserIdTypeUserYearMonthResponseError)

export const getGetChannelIdTypeChannelUserIdTypeUserYearMonthUrl = (channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    year: string,
    month: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserYearMonthParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://logs.ivr.fi/${channelIdType}/${channel}/${userIdType}/${user}/${year}/${month}?${stringifiedParams}` : `https://logs.ivr.fi/${channelIdType}/${channel}/${userIdType}/${user}/${year}/${month}`
}

export const getChannelIdTypeChannelUserIdTypeUserYearMonth = async (channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    year: string,
    month: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserYearMonthParams, options?: RequestInit): Promise<getChannelIdTypeChannelUserIdTypeUserYearMonthResponse> => {
  
  return customFetch<getChannelIdTypeChannelUserIdTypeUserYearMonthResponse>(getGetChannelIdTypeChannelUserIdTypeUserYearMonthUrl(channelIdType,channel,userIdType,user,year,month,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetChannelIdTypeChannelUserIdTypeUserYearMonthQueryKey = (channelIdType?: ChannelIdType,
    channel?: string,
    userIdType?: UserIdType,
    user?: string,
    year?: string,
    month?: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserYearMonthParams,) => {
    return [
    `https://logs.ivr.fi/${channelIdType}/${channel}/${userIdType}/${user}/${year}/${month}`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetChannelIdTypeChannelUserIdTypeUserYearMonthQueryOptions = <TData = Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserYearMonth>>, TError = unknown>(channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    year: string,
    month: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserYearMonthParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserYearMonth>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetChannelIdTypeChannelUserIdTypeUserYearMonthQueryKey(channelIdType,channel,userIdType,user,year,month,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserYearMonth>>> = ({ signal }) => getChannelIdTypeChannelUserIdTypeUserYearMonth(channelIdType,channel,userIdType,user,year,month,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(channelIdType && channel && userIdType && user && year && month), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserYearMonth>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetChannelIdTypeChannelUserIdTypeUserYearMonthQueryResult = NonNullable<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserYearMonth>>>
export type GetChannelIdTypeChannelUserIdTypeUserYearMonthQueryError = unknown


export function useGetChannelIdTypeChannelUserIdTypeUserYearMonth<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserYearMonth>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    year: string,
    month: string,
    params: undefined |  GetChannelIdTypeChannelUserIdTypeUserYearMonthParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserYearMonth>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserYearMonth>>,
          TError,
          Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserYearMonth>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetChannelIdTypeChannelUserIdTypeUserYearMonth<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserYearMonth>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    year: string,
    month: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserYearMonthParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserYearMonth>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserYearMonth>>,
          TError,
          Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserYearMonth>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetChannelIdTypeChannelUserIdTypeUserYearMonth<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserYearMonth>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    year: string,
    month: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserYearMonthParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserYearMonth>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetChannelIdTypeChannelUserIdTypeUserYearMonth<TData = Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserYearMonth>>, TError = unknown>(
 channelIdType: ChannelIdType,
    channel: string,
    userIdType: UserIdType,
    user: string,
    year: string,
    month: string,
    params?: GetChannelIdTypeChannelUserIdTypeUserYearMonthParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getChannelIdTypeChannelUserIdTypeUserYearMonth>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetChannelIdTypeChannelUserIdTypeUserYearMonthQueryOptions(channelIdType,channel,userIdType,user,year,month,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export type postOptoutResponse200 = {
  data: string
  status: 200
}
    
export type postOptoutResponseSuccess = (postOptoutResponse200) & {
  headers: Headers;
};
;

export type postOptoutResponse = (postOptoutResponseSuccess)

export const getPostOptoutUrl = () => {


  

  return `https://logs.ivr.fi/optout`
}

export const postOptout = async ( options?: RequestInit): Promise<postOptoutResponse> => {
  
  return customFetch<postOptoutResponse>(getPostOptoutUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getPostOptoutMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postOptout>>, TError,void, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof postOptout>>, TError,void, TContext> => {

const mutationKey = ['postOptout'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postOptout>>, void> = () => {
          

          return  postOptout(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostOptoutMutationResult = NonNullable<Awaited<ReturnType<typeof postOptout>>>
    
    export type PostOptoutMutationError = unknown

    export const usePostOptout = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postOptout>>, TError,void, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postOptout>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostOptoutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    export type getCapabilitiesResponse200 = {
  data: string[]
  status: 200
}
    
export type getCapabilitiesResponseSuccess = (getCapabilitiesResponse200) & {
  headers: Headers;
};
;

export type getCapabilitiesResponse = (getCapabilitiesResponseSuccess)

export const getGetCapabilitiesUrl = () => {


  

  return `https://logs.ivr.fi/capabilities`
}

export const getCapabilities = async ( options?: RequestInit): Promise<getCapabilitiesResponse> => {
  
  return customFetch<getCapabilitiesResponse>(getGetCapabilitiesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetCapabilitiesQueryKey = () => {
    return [
    `https://logs.ivr.fi/capabilities`
    ] as const;
    }

    
export const getGetCapabilitiesQueryOptions = <TData = Awaited<ReturnType<typeof getCapabilities>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCapabilities>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCapabilitiesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCapabilities>>> = ({ signal }) => getCapabilities({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCapabilities>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCapabilitiesQueryResult = NonNullable<Awaited<ReturnType<typeof getCapabilities>>>
export type GetCapabilitiesQueryError = unknown


export function useGetCapabilities<TData = Awaited<ReturnType<typeof getCapabilities>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCapabilities>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCapabilities>>,
          TError,
          Awaited<ReturnType<typeof getCapabilities>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCapabilities<TData = Awaited<ReturnType<typeof getCapabilities>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCapabilities>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCapabilities>>,
          TError,
          Awaited<ReturnType<typeof getCapabilities>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCapabilities<TData = Awaited<ReturnType<typeof getCapabilities>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCapabilities>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetCapabilities<TData = Awaited<ReturnType<typeof getCapabilities>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCapabilities>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCapabilitiesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




